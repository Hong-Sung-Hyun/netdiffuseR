% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{as_diffnet}
\alias{as_diffnet}
\alias{diffnet}
\alias{diffnet-class}
\alias{plot.diffnet}
\alias{print.diffnet}
\alias{summary.diffnet}
\title{Creates a \code{diffnet} class object}
\usage{
as_diffnet(graph, toa, recode = TRUE, stack.toa.right = TRUE,
  weights = NULL, undirected = getOption("diffnet.undirected"),
  self = getOption("diffnet.self"),
  multiple = getOption("diffnet.multiple"), use.incomplete = FALSE)

\method{plot}{diffnet}(x, y = NULL, t = 1, displaylabels = FALSE,
  vertex.col = c("blue", "grey"), vertex.cex = "degree",
  edge.col = "gray", mode = "fruchtermanreingold", layout.par = NULL,
  main = "Diffusion network in time \%d", ...)

\method{print}{diffnet}(x, ...)

\method{summary}{diffnet}(object, ...)
}
\arguments{
\item{graph}{A dynamic graph (see \code{\link{netdiffuseR-graphs}}).}

\item{toa}{Numeric vector of size \eqn{n}. Times of adoption.}

\item{recode}{Logical scalar. Passed to \code{\link{toa_mat}}.}

\item{stack.toa.right}{Logical scalar. When the range of \code{toa} is smaller than
the number of slices in graph, TRUE stacks the toa to the right (see details).}

\item{weights}{Numeric vector of size \eqn{n}.}

\item{undirected}{Logical scalar.}

\item{self}{Logical scalar.}

\item{multiple}{Logical scalar.}

\item{use.incomplete}{Logical scalar.}

\item{x}{A \code{diffnet} object.}

\item{y}{Ignored.}

\item{t}{Integer scalar indicating the time slice to plot.}

\item{displaylabels}{Logical scalar. When TRUE, \code{plot} shows vertex labels.}

\item{vertex.col}{Character scalar/vector. Color of the vertices.}

\item{vertex.cex}{Numeric scalar/vector. Size of the vertices.}

\item{edge.col}{Character scalar/vector. Color of the edges.}

\item{mode}{Character scalar. Name of the layout algorithm to implement (see details).}

\item{layout.par}{Layout parameters (see details).}

\item{main}{Character. A title template to be passed to sprintf.}

\item{...}{In the case of \code{plot}, further arguments passed to \code{gplot}, otherwise
is ignored.}

\item{object}{A \code{diffnet} object.}
}
\value{
A list of class \code{diffnet} with the following elements:
\item{graph}{A list of length \eqn{T}. Containing sparse square matrices of size \eqn{n}
and class \code{\link[Matrix:dgCMatrix-class]{dgCMatrix}}.}
\item{toa}{An integer vector of size \eqn{T} with times of adoption.}
\item{adopt, cumadopt}{Numeric matrices of size \eqn{n\times T}{n*T} as those returned
by \code{\link{toa_mat}}.}
\item{meta}{A list of length 9 with the following elements:
\itemize{
 \item \code{type}: Character scalar equal to \code{"dynamic"}.
 \item \code{class}: Character scalar equal to \code{"list"}.
 \item \code{ids}: Character vector of size \eqn{n} with vertices' labels.
 \item \code{pers}: Integer vector of size \eqn{T}.
 \item \code{nper}: Integer scalar equal to \eqn{T}.
 \item \code{n}: Integer scalar equal to \eqn{n}.
 \item \code{self}: Logical scalar.
 \item \code{undirected}: Logical scalar.
 \item \code{multiple}: Logical scalar.
}
}
}
\description{
\code{diffnet} objects contain difussion of innovation networks. With adjacency
matrices and time of adoption (toa) vector as its main components, most of the
package's functions have methods for this class of objects.
}
\details{
Plotting is done via the function \code{\link[sna:gplot]{gplot}},
and its layout via \code{\link[sna:gplot.layout]{gplot.layout}}, both from
the (\pkg{sna}) package.

\code{vertex.cex} can either be a numeric scalar, a numeric vector or a character
scalar taking any of the following values \code{"degree"}, \code{"indegree"}, or
\code{"outdegree"}. The later will be passed to \code{\link{dgr}} to calculate
degree of the selected slice and will be normalized as

\deqn{vertex.cex = d/[max(d) - min(d)]\times 2 + .5}{vertex.cex = d/[max(d) - min(d)]* 2 + .5}

where \code{d=sqrt(dgr(graph))}.

When \code{max(toa) - min(toa) <} number of slices in the graph,
\code{stack.toa.right=TRUE} tells the function to assume that \code{max(toa)}
coincides with the last slice of the graph. So, assuming that the range of
the times of adoption is smaller than the set of graphs, we have two cases:
\enumerate{
\item \code{stack.toa.right=TRUE}, then we have

\code{0------------------------T}

\code{||||||||||||||||||||||||||}: graph time line

\code{.....|||||||||||||||||||||}: toa range

\item \code{stack.toa.right=FALSE}, then we have

\code{0------------------------T}

\code{||||||||||||||||||||||||||}: graph time line

\code{|||||||||||||||||||||.....}: toa range
}
}
\examples{

# Creating a random graph
set.seed(123)
graph <- rgraph_ba(t=9)
graph <- lapply(1:5, function(x) graph)

# Pretty TOA
names(graph) <- 2001L:2005L
toa <- sample(c(2001L:2005L,NA), 10, TRUE)

# Creating diffnet object
diffnet <- as_diffnet(graph, toa)
diffnet
summary(diffnet)
}
\seealso{
Default options are listed at \code{\link{netdiffuseR-options}}
}

