% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adjmat.R
\name{edgelist_to_adjmat}
\alias{adjmat_to_edgelist}
\alias{adjmat_to_edgelist.array}
\alias{adjmat_to_edgelist.matrix}
\alias{edgelist_to_adjmat}
\alias{edgelist_to_adjmat.data.frame}
\alias{edgelist_to_adjmat.matrix}
\title{Conversion between adjacency matrix and edgelist}
\usage{
edgelist_to_adjmat(edgelist, ...)

\method{edgelist_to_adjmat}{data.frame}(edgelist, ...)

\method{edgelist_to_adjmat}{matrix}(edgelist, weights = NULL, times = NULL,
  simplify = TRUE, undirected = FALSE, skip.recode = FALSE,
  self = FALSE, multiple = FALSE, use.incomplete = TRUE,
  times.recode = TRUE, ...)

adjmat_to_edgelist(adjmat, undirected = TRUE)

\method{adjmat_to_edgelist}{matrix}(adjmat, undirected = TRUE)

\method{adjmat_to_edgelist}{array}(adjmat, undirected = TRUE)
}
\arguments{
\item{edgelist}{Two column matrix/data.frame in the form of ego -source- and
alter -target- (see details).}

\item{...}{Further arguments for the method.}

\item{weights}{Numeric vector. Strength of ties (optional).}

\item{times}{Integer vector. Periodicity of the ties (optional).}

\item{simplify}{Logical. When TRUE and \code{times=NULL} it will return an adjacency
matrix, otherwise an array of adjacency matrices.}

\item{undirected}{Logical. TRUE when the graph is undirected.}

\item{skip.recode}{Logical. FALSE when recode of nodes's ids is performed (see details).}

\item{self}{Logical. TRUE when self edges are excluded.}

\item{multiple}{Logical. TRUE when multiple edges should not be included
(see details).}

\item{use.incomplete}{Logical. When FALSE, rows with \code{NA/NULL} values will be droped
and will not be considered in the graph, which may reduce the size of the
adjacency matrix (see
details).}

\item{times.recode}{Logical. TRUE when time recoding must be done.}

\item{adjmat}{An \eqn{n\times n}{n * n} matrix. An adjacency matrix.}
}
\value{
In the case of \code{edgelist_to_adjmat} either an adjacency matrix
(if times is NULL) or an array of these (if times is not null). For
\code{adjmat_to_edgelist} the output is an edgelist.
}
\description{
Generates adjacency matrix from an edgelist and viceversa.
}
\details{
The edgelist must be coded from 1:n (otherwise it may cause an error).
By default, the function will \code{\link{recode}} the edgelist before starting.

When multiple edges are included, each vertex between \eqn{\{i,j\}}{{i,j}} will be counted
as many times it appears in the edgelist. So if a vertex \eqn{\{i,j\}}{{i,j}} appears 2
times, the adjacency matrix element \code{(i,j)} will be 2.

Including incomplete cases, \code{use.incomplete=TRUE}, can lead to an adjacency matrix
with isolated vertices. Otherwise, when \code{use.incomplete=FALSE}, if all the
edges in which a vertex participates have incomplete information in any of the
variables (a NA, NULL or NaN value, see \code{\link{complete.cases}}), it
will be dropped from the graph, thus, reducing the size of the adjacency
matrix by not including isolated vertices.

The function performs several checks before starting to create the adjacency
matrix. These are:
\itemize{
 \item{Dimensions of the inputs, such as number of columns and length of vectors}
 \item{Having complete cases. If anly edge has a non-numeric value such as NAs or
 NULL in any variable (including \code{times} and \code{weights}), it will be
 removed. A full list of such edges can be retrieved from the attribute
 \code{incomplete}}
 \item{Nodes and times ids coding}
}
}
\examples{
# Base data
set.seed(123)
n <- 10
edgelist <- rand_graph(n, as.edgelist=TRUE)
times <- sample.int(10, nrow(edgelist), replace=TRUE)
w <- abs(rnorm(nrow(edgelist)))

# Simple example
edgelist_to_adjmat(edgelist)
edgelist_to_adjmat(edgelist, undirected = TRUE)

# Using weights
edgelist_to_adjmat(edgelist, w)
edgelist_to_adjmat(edgelist, w, undirected = TRUE)

# Using times
edgelist_to_adjmat(edgelist, times = times)
edgelist_to_adjmat(edgelist, times = times, undirected = TRUE)

# Using times and weights
edgelist_to_adjmat(edgelist, times = times, weights = w)
edgelist_to_adjmat(edgelist, times = times, undirected = TRUE, weights = w)
}
\keyword{manip}

