#' Random diffnet network
#'
#' Generates a random diffnet network
#'
#' @export
#' @param n Integer scalar. Number of vertices.
#' @param t Integer scalar. Time lenght.
#' @param seeds.nodes Character scalar. Type of seed nodes (early adoptes).
#' @param seed.p.adopt Numeric scalar. Proportion of early adopters.
#' @param rgraph.args List. Arguments to be passed to rgraph.
#' @param rewire Logical scalar. When TRUE, network slices are generated by rewiring
#' (see \code{\link{rewire_graph}}).
#' @param rewire.args List. Arguments to be passed to \code{\link{rewire_graph}}
#' @param threshold.dist Function. Applied via \code{\link{sapply}}, sets the
#' adoption threshold for each node.
#' @return A random \code{\link{diffnet}} class object.
#' @details
#'
#' \code{seed.nodes} can be \code{"marginal"}, \code{"central"} or \code{"random"},
#' So each of these values sets the initial adopters using the vertices with lowest
#' degree, with highest degree or completely randomly. The number of early adoptes
#' is set as \code{seed.p.adopt * n}.
#'
#' The argument \code{seed.graph} allows the user to set the algorithm used to
#' generate the first network (network in t=1). This can be either "scale-free"
#' (Barabasi-Albert model using the \code{\link{rgraph_ba}} function),
#' \code{"bernoulli"} (Erdos-Reyi model using the \code{\link{rgraph_re}} function),
#' or \code{"small-world"} (Watts-Strogatz model using the \code{\link{rgraph_ws}}
#' function). The list \code{rgraph.args} passes arguments to the chosen algorithm.
#'
#' When \code{rewire=TRUE}, the networks that follow t=1 will be generated using the
#' \code{\link{require_graph}} function as \eqn{G(t) = G(t-1)}.
#'
#' Finally, \code{threshold.dist} sets the threshold for each vertex in the graph.
#' It is applied using \code{sapply} as follows
#'
#' \code{sapply(1:n, threshold.dist)}
#'
#' By default sets the threshold to be random for each node in the graph.
#'
#' @examples
#' z <- rdiffnet(50,10)
#' z
#' summary(z)
rdiffnet <- function(n, t,
                     seed.nodes="marginal", seed.p.adopt=0.2,
                     seed.graph="scale-free", rgraph.args=list(),
                     rewire=TRUE, rewire.args=list(p=.2),
                     threshold.dist=function(x) runif(1)
                     ) {

  # Step 0.0: Creating the network seed
  if (seed.graph == "scale-free") {
    if (!length(rgraph.args$m0))
      rgraph.args$t <- n-1L

    sgraph <- do.call(rgraph_ba, rgraph.args)
  } else if (seed.graph == "bernoulli") {
    rgraph.args$n <- n

    sgraph <- do.call(rgraph_er, rgraph.args)
  } else if (seed.graph == "small-world") {
    rgraph.args$n <- n
    rgraph.args$k <- 2L
    rgraph.args$p <- .1

    sgraph <- do.call(rgraph_ws, rgraph.ars)
  }

  # Step 0.1: Setting the seed nodes
  cumadopt <- matrix(0, ncol=t, nrow=n)
  toa   <- matrix(NA, ncol=1, nrow= n)
  if (seed.nodes %in% c("central","marginal")) {
    d <- dgr(sgraph)
    decre <- ifelse(seed.nodes == "central", TRUE, FALSE)
    d <- rownames(d[order(d, decreasing = decre),,drop=FALSE])
    d <- d[1:floor(n*seed.p.adopt)]
    d <- as.numeric(d)
    cumadopt[d, ] <- 1
    toa[d] <- 1
  } else if (seed.nodes == "random") {
    toa[sample.int(n, floor(n*seed.p.adopt))] <- 1
  }

  # Step 1.0: Repeat
  graph      <- vector("list", t)
  graph[[1]] <- sgraph
  if (rewire) {
    for (i in 2:t) {
      rewire.args$graph <- graph[[i-1]]
      graph[[i]] <- do.call(rewire_graph, rewire.args)
    }
  } else {
    graph <- lapply(1:t, function(x) sgraph)
  }

  names(graph) <- 1:t

  # Step 3.0: Thresholds
  thr <- sapply(1:n, threshold.dist)

  for (i in 2:t) {
    expo <- exposure(graph, cumadopt)
    whoadopts <- which( (expo[,i] >= thr) & is.na(toa))
    toa[whoadopts] <- i
    cumadopt[whoadopts, i:t] <- 1
  }
  reachedt <- max(toa, na.rm=TRUE)

  if (reachedt < t) {
    warning("Less periods than wanted, only ",reachedt," instead of ",t)
    graph <- graph[1:reachedt]
  }

  as_diffnet(graph, toa, recode=FALSE)
}

